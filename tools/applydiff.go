package tools

import (
	"fmt"
	"io"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

type ApplyFileDiff struct {
	BaseFileTool
}

func (r *ApplyFileDiff) Name() string {
	return "apply_file_diff"
}

func (r *ApplyFileDiff) Description() string {
	return `Applies a file diff onto an existing file and returns a success or a failure along with the contents of the file being updated incase the diff being applied is based on an older version of the file.  For this patch to be effective it would be ideal to have atleast 5 lines of context before and after each hunk of change if possible`
}

func (r *ApplyFileDiff) Parameters() []*Parameter {
	return []*Parameter{
		{
			Name:        "path",
			Description: "Path of the file to create or overwrite.",
			Type:        "string",
		},
		{
			Name:        "diff",
			Description: "Unix still diff/patch to apply to a file.  If the diff is invalid (for example it is based on an older version of the file) then an error will be thrown",
			Type:        "string",
		},
	}
}

func (r *ApplyFileDiff) Returns() []*Parameter {
	return []*Parameter{
		{
			Name:        "result",
			Description: "Error or Number of bytes written",
			Type:        "object",
		},
	}
}

func (r *ApplyFileDiff) Run(args map[string]any) (any, error) {
	path := args["path"].(string)
	diff := args["diff"].(string)
	fullpath, err := r.ResolvePath(path)
	if err != nil {
		return nil, err
	}

	// TODO - replace with stat

	return r.RunWithPatch(fullpath, diff)
}

func saveInputAndPatch(fullpath, diff string) (tempdir, tempInFile, tempPatchFile string, inputLines []string, diffLines []string, err error) {
	currcontents, err := os.ReadFile(fullpath)
	if err != nil {
		log.Println("Error reading file: ", err)
		return
	}

	tempdir, err = os.MkdirTemp("", "sampledir")
	if err != nil {
		panic(err)
	}
	tempdir = "/tmp"
	tempInFile = filepath.Join(tempdir, "inputfile")
	tempPatchFile = filepath.Join(tempdir, "patchfile")

	log.Println("Creating Temporary Directory: ", tempdir)
	log.Println("Temporary Input File Path: ", tempInFile)
	log.Println("Temporary Patch File Path: ", tempPatchFile)

	if err = os.WriteFile(tempInFile, currcontents, 0666); err != nil {
		panic(err)
	}
	if err = os.WriteFile(tempPatchFile, []byte(diff), 0666); err != nil {
		panic(err)
	}

	inputLines = strings.Split(string(currcontents), "\n")
	diffLines = strings.Split(diff, "\n")
	return
}

// The output generated by an LLM for a unix patch is very flaky.   It fails more often then not.
// Also it is silly to blindly apply a patch.   Perhaps better to show the side by side diff and
// have the user apply it.
// The patch out is flaky in the following areas:
//   - line number offsets are wrong
//   - usually based on an "older" version of a file - ie it may not always call the read_file or even
//     ignore your version of the file
//
// So the idea is there may still be enough markers in the diff to identify where a diff begins so we can
// iterate through the original file along with the diff contents and see waht is already "common".  We may
// not even need a full edit distance algo for this.
func (r *ApplyFileDiff) RunWithInteractiveDiff(fullpath, diff string) (any, error) {
	// tempDir, _, _, inputLines, diffLines, _ := saveInputAndPatch(fullpath, diff)
	tempDir, _, tempPatchFile, inputLines, diffLines, err := saveInputAndPatch(fullpath, diff)
	if err != nil {
		return nil, err
	}
	outputFile := filepath.Join(tempDir, "outputfile")

	ec := (&EditCosts{InLines: inputLines, DiffLines: diffLines}).Init()
	cost := ec.Dist()
	log.Println("Costs: ", cost)
	outputlines := ec.ApplyPatchToInput()
	outputbytes := []byte(strings.Join(outputlines, "\n"))
	if err = os.WriteFile(outputFile, outputbytes, 0666); err != nil {
		panic(err)
	}

	// atmost one of diff or input pointer would have reached the end - so copy the rest over

	log.Println("Patch written to: ", tempPatchFile)
	log.Println("Patched File written to: ", outputFile)

	var input int
	for input < 1 || input > 2 {
		fmt.Println("")
		fmt.Printf("1. Override %s with patched output (%s)\n", fullpath, outputFile)
		fmt.Println("2. Do nothing and cancel patching")
		fmt.Println("")
		fmt.Print("What would you like to do? - ")
		fmt.Scanln(&input)
	}

	if input == 1 {
		if err = os.WriteFile(outputFile, outputbytes, 0666); err != nil {
			panic(err)
		}
		log.Printf("Updated %s", fullpath)
		return "SUCCESS", nil
	}

	return nil, nil

	// now generate the stuff onto this
	// return nil, nil
}

// Tries to apply the patch by calling the unix patch command
func (r *ApplyFileDiff) RunWithPatch(fullpath, diff string) (any, error) {
	tempDir, tempInFile, tempPatchFile, _, _, err := saveInputAndPatch(fullpath, diff)
	if err != nil {
		return nil, err
	}
	outputFile := filepath.Join(tempDir, "outputfile")

	log.Printf("Running patch -u %s -i %s", tempInFile, tempPatchFile)
	cmd := exec.Command("patch", "-u", tempInFile, "-i", tempPatchFile, "-o", outputFile)
	stderr, err := cmd.StderrPipe()
	if err != nil {
		log.Println("Cannot get stderr: ", err)
		return nil, err
	}
	stdout, err := cmd.StdoutPipe()
	if err != nil {
		log.Println("Cannot get stdout: ", err)
		return nil, err
	}

	if err = cmd.Start(); err != nil {
		log.Fatal("Could not sart command: ", err)
	}

	output, err := io.ReadAll(stdout)
	errout, err := io.ReadAll(stderr)

	if err := cmd.Wait(); err != nil {
		log.Println("Error patching: ", err.Error(), errout)
		log.Println("Error Output: ", string(errout))
		log.Println("Std Output: ", string(output))
		log.Println("Could not wait: ", err)
		if string(errout) != "" {
			return string(errout), nil
		}
		return string(output), nil
	}

	log.Println("Patch result: ", output)
	return "SUCCESS", nil
}
