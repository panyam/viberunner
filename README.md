What did we learn about Vibe Coding

Going to cursor or loveable and doing a one shot thing is horrible.   You are making waaaaay too many rewrites and is too flaky.

Frustrating thing is as something gets complicated - artifacts are waaaaay to bloated and small asks (via prompts)
results in massive rewrites.

We already have components in mind - or atleast we want components to be the basic building blocks that the LLM plays
around with instead of the "char" being the basic building block.

One thing that worked is incrementality and CONSTANTLY FORCING incrementality.   This has parallels in grammers - eg
reduce at the right time and reduce often.

Another way is let LLM do X things (A, B, C ... X) - ask it reduce the X things and start from A again as if it is a new
branch by distilled all you have learnt as part of this checkpoint.  Distilling is not same as summarization.

Another one is feedback.  What ever you have learnt needs to be "tried" so we can learn from it.  However this does not
need to be part of the context.  Just the learning needs to be.

So LLM environments need a few things:

* Knowledge - Memory or Current State of the univers (can include long and short term).   This is all things we know or
  have learnt so far.

* Rules - Constraints of what we know so far and explicit bounds on how to represent them and what to avoid.   For
  example telling an LLM that all generated artifacts must be less then 20 lines is one such rule.  Another is saying
  our base HTML should only contain template blocks and css and no content is another rule.  This can also include other
  filters (More on this).

* Generators - These are (obviously) LLMs that are generating artifacts (or parts of it) responding to prompts.  Based
  on our current knowledge and rules takes a prompt and generates an artifact conforming to the rules.

* Artifacts/Actions - These are what are generated by the Generators and can be recommendations on what to do (say
  actions) or content/artifacts to embed into the world (that Actors/Runners can use to do things and give feedback)

* Runners - Something needs to take an artifact, embed into the current running world and show what is happening - ie
  get feedback.   This does not have to be fully automatic.  For example if the Generator says here is the code for X,
  that X needs to be embedded into the Runner (say X.java has this code now) and run again - say running a series of
  test.   These tests can be automatic or manual.  The output needs to be passed back to the Engine (and to the
  Generator) via feedback.   Similarly our WOrld model (knowledge/rules) may also have to be updated somehow
